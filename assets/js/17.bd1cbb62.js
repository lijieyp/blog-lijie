(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{150:function(t,e,n){"use strict";n.r(e);var o=n(0),r=Object(o.a)({},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"什么是函数式组件？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是函数式组件？","aria-hidden":"true"}},[t._v("#")]),t._v(" 什么是函数式组件？")]),t._v(" "),n("p",[t._v("函数式组件是指用一个Function来渲染一个vue组件，这个组件只接受一些 prop，我们可以将这类组件标记为 functional，这意味着它无状态 (没有响应式数据)，也没有实例 (没有this上下文)。")]),t._v(" "),n("p",[t._v("一个函数式组件大概像下面这样：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("export default () => {\n  functional: true, \n  props: { \n    // Props 是可选的\n  },\n  // 为了弥补缺少的实例, 提供第二个参数作为上下文\n  render: function (createElement, context) {\n    return vNode\n  }\n}\n")])])]),n("p",[t._v("注意：在 2.3.0 之前的版本中，如果一个函数式组件想要接收 prop，则 props 选项是必须的。在 2.3.0 或以上的版本中，你可以省略 props 选项，所有组件上的特性都会被自动隐式解析为 prop。但是你一旦注册了 prop 那么只有被注册的 prop 会出现在 context.prop 里。")]),t._v(" "),n("p",[t._v("render函数的第二个参数context用来代替上下文this他是一个包含如下字段的对象：")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("props：提供所有 prop 的对象，所有data.attrs中的属性都会自动解析为props。")])]),t._v(" "),n("li",[n("p",[t._v("children: VNode 子节点的数组，包含所有插槽内容")])]),t._v(" "),n("li",[n("p",[t._v("slots: 一个函数，返回了包含所有插槽的对象")])]),t._v(" "),n("li",[n("p",[t._v("scopedSlots: (2.6.0+) 一个暴露传入的作用域插槽的对象。也以函数形式暴露普通插槽。")])]),t._v(" "),n("li",[n("p",[t._v("data：传递给组件的整个数据对象，作为 createElement 的第二个参数传入组件")]),t._v(" "),n("p",[t._v("组件上的属性会被解析到data.attrs中，class会被解析为staticClass，style解析为style，绑定的事件解析到on中，v-model会在data.attrs和model中解析一个value属性和on中解析一个input属性。")])]),t._v(" "),n("li",[n("p",[t._v("parent：对父组件的引用")])]),t._v(" "),n("li",[n("p",[t._v("listeners: (2.3.0+) 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是 data.on 的一个别名。")])]),t._v(" "),n("li",[n("p",[t._v("injections: (2.3.0+) 如果使用了 inject 选项，则该对象包含了应当被注入的属性。")])])]),t._v(" "),n("p",[t._v("在添加 "),n("code",[t._v("functional: true")]),t._v(" 之后，需要更新我们的锚点标题组件的渲染函数，为其增加 "),n("code",[t._v("context")]),t._v("参数，并将 "),n("code",[t._v("this.$slots.default")]),t._v(" 更新为 "),n("code",[t._v("context.children")]),t._v("，然后将 "),n("code",[t._v("this.level")]),t._v(" 更新为 "),n("code",[t._v("context.props.level")]),t._v("。")]),t._v(" "),n("p",[t._v("因为函数式组件只是函数，所以渲染开销也低很多。")]),t._v(" "),n("p",[t._v("在作为包装组件时它们也同样非常有用。比如，当你需要做这些时：")]),t._v(" "),n("ul",[n("li",[t._v("程序化地在多个组件中选择一个来代为渲染；")]),t._v(" "),n("li",[t._v("在将 "),n("code",[t._v("children")]),t._v("、"),n("code",[t._v("props")]),t._v("、"),n("code",[t._v("data")]),t._v(" 传递给子组件之前操作它们。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('<FunctionComponent \n\t:componentType="componentType" \n\t:labelName="labelName" \n\tclass="qwe" \n\t@abcd="resetForm" \n\tv-model="model1" \n\t:style="styles">\n</FunctionComponent>\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import _ from 'lodash';\nfunction getChildren(h,ctx){\n  const children=ctx.props.children||{};\n  const items=children.items||[];\n  return items.map(item=>{\n    return h(children.sytnax,{props:item})\n  })\n}\nexport default {\n  name:'FunctionComponent',\n  functional:true,\n  render (h, ctx) {\n    return h(\n      ctx.props.componentType,\n      _.merge(\n          ctx.data,\n          ctx.props\n      ),\n      ctx.children\n    )\n  },\n}\n")])])])])},[],!1,null,null,null);e.default=r.exports}}]);